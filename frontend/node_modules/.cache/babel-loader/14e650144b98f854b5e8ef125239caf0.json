{"ast":null,"code":"/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nconst debug = require('debug')('simple-peer');\n\nconst getBrowserRTC = require('get-browser-rtc');\n\nconst randombytes = require('randombytes');\n\nconst stream = require('readable-stream');\n\nconst queueMicrotask = require('queue-microtask'); // TODO: remove when Node 10 is not supported\n\n\nconst errCode = require('err-code');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst MAX_BUFFERED_AMOUNT = 64 * 1024;\nconst ICECOMPLETE_TIMEOUT = 5 * 1000;\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000; // HACK: Filter trickle lines when trickle is disabled #354\n\nfunction filterTrickle(sdp) {\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '');\n}\n\nfunction warn(message) {\n  console.warn(message);\n}\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */\n\n\nclass Peer extends stream.Duplex {\n  constructor(opts) {\n    opts = Object.assign({\n      allowHalfOpen: false\n    }, opts);\n    super(opts);\n    this._id = randombytes(4).toString('hex').slice(0, 7);\n\n    this._debug('new peer %o', opts);\n\n    this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString('hex') : null;\n    this.initiator = opts.initiator || false;\n    this.channelConfig = opts.channelConfig || Peer.channelConfig;\n    this.channelNegotiated = this.channelConfig.negotiated;\n    this.config = Object.assign({}, Peer.config, opts.config);\n    this.offerOptions = opts.offerOptions || {};\n    this.answerOptions = opts.answerOptions || {};\n\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp);\n\n    this.streams = opts.streams || (opts.stream ? [opts.stream] : []); // support old \"stream\" option\n\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true;\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false;\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;\n    this.destroyed = false;\n    this.destroying = false;\n    this._connected = false;\n    this.remoteAddress = undefined;\n    this.remoteFamily = undefined;\n    this.remotePort = undefined;\n    this.localAddress = undefined;\n    this.localFamily = undefined;\n    this.localPort = undefined;\n    this._wrtc = opts.wrtc && typeof opts.wrtc === 'object' ? opts.wrtc : getBrowserRTC();\n\n    if (!this._wrtc) {\n      if (typeof window === 'undefined') {\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT');\n      } else {\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT');\n      }\n    }\n\n    this._pcReady = false;\n    this._channelReady = false;\n    this._iceComplete = false; // ice candidate trickle done (got null candidate)\n\n    this._iceCompleteTimer = null; // send an offer/answer anyway after some timeout\n\n    this._channel = null;\n    this._pendingCandidates = [];\n    this._isNegotiating = false; // is this peer waiting for negotiation to complete?\n\n    this._firstNegotiation = true;\n    this._batchedNegotiation = false; // batch synchronous negotiations\n\n    this._queuedNegotiation = false; // is there a queued negotiation request?\n\n    this._sendersAwaitingStable = [];\n    this._senderMap = new Map();\n    this._closingInterval = null;\n    this._remoteTracks = [];\n    this._remoteStreams = [];\n    this._chunk = null;\n    this._cb = null;\n    this._interval = null;\n\n    try {\n      this._pc = new this._wrtc.RTCPeerConnection(this.config);\n    } catch (err) {\n      this.destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'));\n      return;\n    } // We prefer feature detection whenever possible, but sometimes that's not\n    // possible for certain implementations.\n\n\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number';\n\n    this._pc.oniceconnectionstatechange = () => {\n      this._onIceStateChange();\n    };\n\n    this._pc.onicegatheringstatechange = () => {\n      this._onIceStateChange();\n    };\n\n    this._pc.onconnectionstatechange = () => {\n      this._onConnectionStateChange();\n    };\n\n    this._pc.onsignalingstatechange = () => {\n      this._onSignalingStateChange();\n    };\n\n    this._pc.onicecandidate = event => {\n      this._onIceCandidate(event);\n    }; // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\n\n\n    if (typeof this._pc.peerIdentity === 'object') {\n      this._pc.peerIdentity.catch(err => {\n        this.destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'));\n      });\n    } // Other spec events, unused by this implementation:\n    // - onconnectionstatechange\n    // - onicecandidateerror\n    // - onfingerprintfailure\n    // - onnegotiationneeded\n\n\n    if (this.initiator || this.channelNegotiated) {\n      this._setupData({\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\n      });\n    } else {\n      this._pc.ondatachannel = event => {\n        this._setupData(event);\n      };\n    }\n\n    if (this.streams) {\n      this.streams.forEach(stream => {\n        this.addStream(stream);\n      });\n    }\n\n    this._pc.ontrack = event => {\n      this._onTrack(event);\n    };\n\n    this._debug('initial negotiation');\n\n    this._needsNegotiation();\n\n    this._onFinishBound = () => {\n      this._onFinish();\n    };\n\n    this.once('finish', this._onFinishBound);\n  }\n\n  get bufferSize() {\n    return this._channel && this._channel.bufferedAmount || 0;\n  } // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n\n\n  get connected() {\n    return this._connected && this._channel.readyState === 'open';\n  }\n\n  address() {\n    return {\n      port: this.localPort,\n      family: this.localFamily,\n      address: this.localAddress\n    };\n  }\n\n  signal(data) {\n    if (this.destroying) return;\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED');\n\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (err) {\n        data = {};\n      }\n    }\n\n    this._debug('signal()');\n\n    if (data.renegotiate && this.initiator) {\n      this._debug('got request to renegotiate');\n\n      this._needsNegotiation();\n    }\n\n    if (data.transceiverRequest && this.initiator) {\n      this._debug('got request for transceiver');\n\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);\n    }\n\n    if (data.candidate) {\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\n        this._addIceCandidate(data.candidate);\n      } else {\n        this._pendingCandidates.push(data.candidate);\n      }\n    }\n\n    if (data.sdp) {\n      this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(() => {\n        if (this.destroyed) return;\n\n        this._pendingCandidates.forEach(candidate => {\n          this._addIceCandidate(candidate);\n        });\n\n        this._pendingCandidates = [];\n        if (this._pc.remoteDescription.type === 'offer') this._createAnswer();\n      }).catch(err => {\n        this.destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'));\n      });\n    }\n\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\n      this.destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'));\n    }\n  }\n\n  _addIceCandidate(candidate) {\n    const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);\n\n    this._pc.addIceCandidate(iceCandidateObj).catch(err => {\n      if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\n        warn('Ignoring unsupported ICE candidate.');\n      } else {\n        this.destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'));\n      }\n    });\n  }\n  /**\r\n   * Send text/binary data to the remote peer.\r\n   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk\r\n   */\n\n\n  send(chunk) {\n    if (this.destroying) return;\n    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED');\n\n    this._channel.send(chunk);\n  }\n  /**\r\n   * Add a Transceiver to the connection.\r\n   * @param {String} kind\r\n   * @param {Object} init\r\n   */\n\n\n  addTransceiver(kind, init) {\n    if (this.destroying) return;\n    if (this.destroyed) throw errCode(new Error('cannot addTransceiver after peer is destroyed'), 'ERR_DESTROYED');\n\n    this._debug('addTransceiver()');\n\n    if (this.initiator) {\n      try {\n        this._pc.addTransceiver(kind, init);\n\n        this._needsNegotiation();\n      } catch (err) {\n        this.destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'));\n      }\n    } else {\n      this.emit('signal', {\n        // request initiator to renegotiate\n        type: 'transceiverRequest',\n        transceiverRequest: {\n          kind,\n          init\n        }\n      });\n    }\n  }\n  /**\r\n   * Add a MediaStream to the connection.\r\n   * @param {MediaStream} stream\r\n   */\n\n\n  addStream(stream) {\n    if (this.destroying) return;\n    if (this.destroyed) throw errCode(new Error('cannot addStream after peer is destroyed'), 'ERR_DESTROYED');\n\n    this._debug('addStream()');\n\n    stream.getTracks().forEach(track => {\n      this.addTrack(track, stream);\n    });\n  }\n  /**\r\n   * Add a MediaStreamTrack to the connection.\r\n   * @param {MediaStreamTrack} track\r\n   * @param {MediaStream} stream\r\n   */\n\n\n  addTrack(track, stream) {\n    if (this.destroying) return;\n    if (this.destroyed) throw errCode(new Error('cannot addTrack after peer is destroyed'), 'ERR_DESTROYED');\n\n    this._debug('addTrack()');\n\n    const submap = this._senderMap.get(track) || new Map(); // nested Maps map [track, stream] to sender\n\n    let sender = submap.get(stream);\n\n    if (!sender) {\n      sender = this._pc.addTrack(track, stream);\n      submap.set(stream, sender);\n\n      this._senderMap.set(track, submap);\n\n      this._needsNegotiation();\n    } else if (sender.removed) {\n      throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED');\n    } else {\n      throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED');\n    }\n  }\n  /**\r\n   * Replace a MediaStreamTrack by another in the connection.\r\n   * @param {MediaStreamTrack} oldTrack\r\n   * @param {MediaStreamTrack} newTrack\r\n   * @param {MediaStream} stream\r\n   */\n\n\n  replaceTrack(oldTrack, newTrack, stream) {\n    if (this.destroying) return;\n    if (this.destroyed) throw errCode(new Error('cannot replaceTrack after peer is destroyed'), 'ERR_DESTROYED');\n\n    this._debug('replaceTrack()');\n\n    const submap = this._senderMap.get(oldTrack);\n\n    const sender = submap ? submap.get(stream) : null;\n\n    if (!sender) {\n      throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED');\n    }\n\n    if (newTrack) this._senderMap.set(newTrack, submap);\n\n    if (sender.replaceTrack != null) {\n      sender.replaceTrack(newTrack);\n    } else {\n      this.destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'));\n    }\n  }\n  /**\r\n   * Remove a MediaStreamTrack from the connection.\r\n   * @param {MediaStreamTrack} track\r\n   * @param {MediaStream} stream\r\n   */\n\n\n  removeTrack(track, stream) {\n    if (this.destroying) return;\n    if (this.destroyed) throw errCode(new Error('cannot removeTrack after peer is destroyed'), 'ERR_DESTROYED');\n\n    this._debug('removeSender()');\n\n    const submap = this._senderMap.get(track);\n\n    const sender = submap ? submap.get(stream) : null;\n\n    if (!sender) {\n      throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED');\n    }\n\n    try {\n      sender.removed = true;\n\n      this._pc.removeTrack(sender);\n    } catch (err) {\n      if (err.name === 'NS_ERROR_UNEXPECTED') {\n        this._sendersAwaitingStable.push(sender); // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n\n      } else {\n        this.destroy(errCode(err, 'ERR_REMOVE_TRACK'));\n      }\n    }\n\n    this._needsNegotiation();\n  }\n  /**\r\n   * Remove a MediaStream from the connection.\r\n   * @param {MediaStream} stream\r\n   */\n\n\n  removeStream(stream) {\n    if (this.destroying) return;\n    if (this.destroyed) throw errCode(new Error('cannot removeStream after peer is destroyed'), 'ERR_DESTROYED');\n\n    this._debug('removeSenders()');\n\n    stream.getTracks().forEach(track => {\n      this.removeTrack(track, stream);\n    });\n  }\n\n  _needsNegotiation() {\n    this._debug('_needsNegotiation');\n\n    if (this._batchedNegotiation) return; // batch synchronous renegotiations\n\n    this._batchedNegotiation = true;\n    queueMicrotask(() => {\n      this._batchedNegotiation = false;\n\n      if (this.initiator || !this._firstNegotiation) {\n        this._debug('starting batched negotiation');\n\n        this.negotiate();\n      } else {\n        this._debug('non-initiator initial negotiation request discarded');\n      }\n\n      this._firstNegotiation = false;\n    });\n  }\n\n  negotiate() {\n    if (this.destroying) return;\n    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED');\n\n    if (this.initiator) {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true;\n\n        this._debug('already negotiating, queueing');\n      } else {\n        this._debug('start negotiation');\n\n        setTimeout(() => {\n          // HACK: Chrome crashes if we immediately call createOffer\n          this._createOffer();\n        }, 0);\n      }\n    } else {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true;\n\n        this._debug('already negotiating, queueing');\n      } else {\n        this._debug('requesting negotiation from initiator');\n\n        this.emit('signal', {\n          // request initiator to renegotiate\n          type: 'renegotiate',\n          renegotiate: true\n        });\n      }\n    }\n\n    this._isNegotiating = true;\n  } // TODO: Delete this method once readable-stream is updated to contain a default\n  // implementation of destroy() that automatically calls _destroy()\n  // See: https://github.com/nodejs/readable-stream/issues/283\n\n\n  destroy(err) {\n    this._destroy(err, () => {});\n  }\n\n  _destroy(err, cb) {\n    if (this.destroyed || this.destroying) return;\n    this.destroying = true;\n\n    this._debug('destroying (error: %s)', err && (err.message || err));\n\n    queueMicrotask(() => {\n      // allow events concurrent with the call to _destroy() to fire (see #692)\n      this.destroyed = true;\n      this.destroying = false;\n\n      this._debug('destroy (error: %s)', err && (err.message || err));\n\n      this.readable = this.writable = false;\n      if (!this._readableState.ended) this.push(null);\n      if (!this._writableState.finished) this.end();\n      this._connected = false;\n      this._pcReady = false;\n      this._channelReady = false;\n      this._remoteTracks = null;\n      this._remoteStreams = null;\n      this._senderMap = null;\n      clearInterval(this._closingInterval);\n      this._closingInterval = null;\n      clearInterval(this._interval);\n      this._interval = null;\n      this._chunk = null;\n      this._cb = null;\n      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound);\n      this._onFinishBound = null;\n\n      if (this._channel) {\n        try {\n          this._channel.close();\n        } catch (err) {} // allow events concurrent with destruction to be handled\n\n\n        this._channel.onmessage = null;\n        this._channel.onopen = null;\n        this._channel.onclose = null;\n        this._channel.onerror = null;\n      }\n\n      if (this._pc) {\n        try {\n          this._pc.close();\n        } catch (err) {} // allow events concurrent with destruction to be handled\n\n\n        this._pc.oniceconnectionstatechange = null;\n        this._pc.onicegatheringstatechange = null;\n        this._pc.onsignalingstatechange = null;\n        this._pc.onicecandidate = null;\n        this._pc.ontrack = null;\n        this._pc.ondatachannel = null;\n      }\n\n      this._pc = null;\n      this._channel = null;\n      if (err) this.emit('error', err);\n      this.emit('close');\n      cb();\n    });\n  }\n\n  _setupData(event) {\n    if (!event.channel) {\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n      // which is invalid behavior. Handle it gracefully.\n      // See: https://github.com/feross/simple-peer/issues/163\n      return this.destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'));\n    }\n\n    this._channel = event.channel;\n    this._channel.binaryType = 'arraybuffer';\n\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;\n    }\n\n    this.channelName = this._channel.label;\n\n    this._channel.onmessage = event => {\n      this._onChannelMessage(event);\n    };\n\n    this._channel.onbufferedamountlow = () => {\n      this._onChannelBufferedAmountLow();\n    };\n\n    this._channel.onopen = () => {\n      this._onChannelOpen();\n    };\n\n    this._channel.onclose = () => {\n      this._onChannelClose();\n    };\n\n    this._channel.onerror = event => {\n      const err = event.error instanceof Error ? event.error : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`);\n      this.destroy(errCode(err, 'ERR_DATA_CHANNEL'));\n    }; // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n\n\n    let isClosing = false;\n    this._closingInterval = setInterval(() => {\n      // No \"onclosing\" event\n      if (this._channel && this._channel.readyState === 'closing') {\n        if (isClosing) this._onChannelClose(); // closing timed out: equivalent to onclose firing\n\n        isClosing = true;\n      } else {\n        isClosing = false;\n      }\n    }, CHANNEL_CLOSING_TIMEOUT);\n  }\n\n  _read() {}\n\n  _write(chunk, encoding, cb) {\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'));\n\n    if (this._connected) {\n      try {\n        this.send(chunk);\n      } catch (err) {\n        return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'));\n      }\n\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount);\n\n        this._cb = cb;\n      } else {\n        cb(null);\n      }\n    } else {\n      this._debug('write before connect');\n\n      this._chunk = chunk;\n      this._cb = cb;\n    }\n  } // When stream finishes writing, close socket. Half open connections are not\n  // supported.\n\n\n  _onFinish() {\n    if (this.destroyed) return; // Wait a bit before destroying so the socket flushes.\n    // TODO: is there a more reliable way to accomplish this?\n\n    const destroySoon = () => {\n      setTimeout(() => this.destroy(), 1000);\n    };\n\n    if (this._connected) {\n      destroySoon();\n    } else {\n      this.once('connect', destroySoon);\n    }\n  }\n\n  _startIceCompleteTimeout() {\n    if (this.destroyed) return;\n    if (this._iceCompleteTimer) return;\n\n    this._debug('started iceComplete timeout');\n\n    this._iceCompleteTimer = setTimeout(() => {\n      if (!this._iceComplete) {\n        this._iceComplete = true;\n\n        this._debug('iceComplete timeout completed');\n\n        this.emit('iceTimeout');\n        this.emit('_iceComplete');\n      }\n    }, this.iceCompleteTimeout);\n  }\n\n  _createOffer() {\n    if (this.destroyed) return;\n\n    this._pc.createOffer(this.offerOptions).then(offer => {\n      if (this.destroyed) return;\n      if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp);\n      offer.sdp = this.sdpTransform(offer.sdp);\n\n      const sendOffer = () => {\n        if (this.destroyed) return;\n        const signal = this._pc.localDescription || offer;\n\n        this._debug('signal');\n\n        this.emit('signal', {\n          type: signal.type,\n          sdp: signal.sdp\n        });\n      };\n\n      const onSuccess = () => {\n        this._debug('createOffer success');\n\n        if (this.destroyed) return;\n        if (this.trickle || this._iceComplete) sendOffer();else this.once('_iceComplete', sendOffer); // wait for candidates\n      };\n\n      const onError = err => {\n        this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'));\n      };\n\n      this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);\n    }).catch(err => {\n      this.destroy(errCode(err, 'ERR_CREATE_OFFER'));\n    });\n  }\n\n  _requestMissingTransceivers() {\n    if (this._pc.getTransceivers) {\n      this._pc.getTransceivers().forEach(transceiver => {\n        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\n          transceiver.requested = true; // HACK: Safari returns negotiated transceivers with a null mid\n\n          this.addTransceiver(transceiver.sender.track.kind);\n        }\n      });\n    }\n  }\n\n  _createAnswer() {\n    if (this.destroyed) return;\n\n    this._pc.createAnswer(this.answerOptions).then(answer => {\n      if (this.destroyed) return;\n      if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp);\n      answer.sdp = this.sdpTransform(answer.sdp);\n\n      const sendAnswer = () => {\n        if (this.destroyed) return;\n        const signal = this._pc.localDescription || answer;\n\n        this._debug('signal');\n\n        this.emit('signal', {\n          type: signal.type,\n          sdp: signal.sdp\n        });\n        if (!this.initiator) this._requestMissingTransceivers();\n      };\n\n      const onSuccess = () => {\n        if (this.destroyed) return;\n        if (this.trickle || this._iceComplete) sendAnswer();else this.once('_iceComplete', sendAnswer);\n      };\n\n      const onError = err => {\n        this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'));\n      };\n\n      this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);\n    }).catch(err => {\n      this.destroy(errCode(err, 'ERR_CREATE_ANSWER'));\n    });\n  }\n\n  _onConnectionStateChange() {\n    if (this.destroyed) return;\n\n    if (this._pc.connectionState === 'failed') {\n      this.destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'));\n    }\n  }\n\n  _onIceStateChange() {\n    if (this.destroyed) return;\n    const iceConnectionState = this._pc.iceConnectionState;\n    const iceGatheringState = this._pc.iceGatheringState;\n\n    this._debug('iceStateChange (connection: %s) (gathering: %s)', iceConnectionState, iceGatheringState);\n\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState);\n\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\n      this._pcReady = true;\n\n      this._maybeReady();\n    }\n\n    if (iceConnectionState === 'failed') {\n      this.destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'));\n    }\n\n    if (iceConnectionState === 'closed') {\n      this.destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'));\n    }\n  }\n\n  getStats(cb) {\n    // statreports can come with a value array instead of properties\n    const flattenValues = report => {\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\n        report.values.forEach(value => {\n          Object.assign(report, value);\n        });\n      }\n\n      return report;\n    }; // Promise-based getStats() (standard)\n\n\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\n      this._pc.getStats().then(res => {\n        const reports = [];\n        res.forEach(report => {\n          reports.push(flattenValues(report));\n        });\n        cb(null, reports);\n      }, err => cb(err)); // Single-parameter callback-based getStats() (non-standard)\n\n    } else if (this._pc.getStats.length > 0) {\n      this._pc.getStats(res => {\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\n        if (this.destroyed) return;\n        const reports = [];\n        res.result().forEach(result => {\n          const report = {};\n          result.names().forEach(name => {\n            report[name] = result.stat(name);\n          });\n          report.id = result.id;\n          report.type = result.type;\n          report.timestamp = result.timestamp;\n          reports.push(flattenValues(report));\n        });\n        cb(null, reports);\n      }, err => cb(err)); // Unknown browser, skip getStats() since it's anyone's guess which style of\n      // getStats() they implement.\n\n    } else {\n      cb(null, []);\n    }\n  }\n\n  _maybeReady() {\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady);\n\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return;\n    this._connecting = true; // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\n\n    const findCandidatePair = () => {\n      if (this.destroyed) return;\n      this.getStats((err, items) => {\n        if (this.destroyed) return; // Treat getStats error as non-fatal. It's not essential.\n\n        if (err) items = [];\n        const remoteCandidates = {};\n        const localCandidates = {};\n        const candidatePairs = {};\n        let foundSelectedCandidatePair = false;\n        items.forEach(item => {\n          // TODO: Once all browsers support the hyphenated stats report types, remove\n          // the non-hypenated ones\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\n            remoteCandidates[item.id] = item;\n          }\n\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\n            localCandidates[item.id] = item;\n          }\n\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\n            candidatePairs[item.id] = item;\n          }\n        });\n\n        const setSelectedCandidatePair = selectedCandidatePair => {\n          foundSelectedCandidatePair = true;\n          let local = localCandidates[selectedCandidatePair.localCandidateId];\n\n          if (local && (local.ip || local.address)) {\n            // Spec\n            this.localAddress = local.ip || local.address;\n            this.localPort = Number(local.port);\n          } else if (local && local.ipAddress) {\n            // Firefox\n            this.localAddress = local.ipAddress;\n            this.localPort = Number(local.portNumber);\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\n            // TODO: remove this once Chrome 58 is released\n            local = selectedCandidatePair.googLocalAddress.split(':');\n            this.localAddress = local[0];\n            this.localPort = Number(local[1]);\n          }\n\n          if (this.localAddress) {\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4';\n          }\n\n          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];\n\n          if (remote && (remote.ip || remote.address)) {\n            // Spec\n            this.remoteAddress = remote.ip || remote.address;\n            this.remotePort = Number(remote.port);\n          } else if (remote && remote.ipAddress) {\n            // Firefox\n            this.remoteAddress = remote.ipAddress;\n            this.remotePort = Number(remote.portNumber);\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\n            // TODO: remove this once Chrome 58 is released\n            remote = selectedCandidatePair.googRemoteAddress.split(':');\n            this.remoteAddress = remote[0];\n            this.remotePort = Number(remote[1]);\n          }\n\n          if (this.remoteAddress) {\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4';\n          }\n\n          this._debug('connect local: %s:%s remote: %s:%s', this.localAddress, this.localPort, this.remoteAddress, this.remotePort);\n        };\n\n        items.forEach(item => {\n          // Spec-compliant\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);\n          } // Old implementations\n\n\n          if (item.type === 'googCandidatePair' && item.googActiveConnection === 'true' || (item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected) {\n            setSelectedCandidatePair(item);\n          }\n        }); // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\n        // But wait until at least 1 candidate pair is available\n\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\n          setTimeout(findCandidatePair, 100);\n          return;\n        } else {\n          this._connecting = false;\n          this._connected = true;\n        }\n\n        if (this._chunk) {\n          try {\n            this.send(this._chunk);\n          } catch (err) {\n            return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'));\n          }\n\n          this._chunk = null;\n\n          this._debug('sent chunk from \"write before connect\"');\n\n          const cb = this._cb;\n          this._cb = null;\n          cb(null);\n        } // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\n        // fallback to using setInterval to implement backpressure.\n\n\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\n          this._interval = setInterval(() => this._onInterval(), 150);\n          if (this._interval.unref) this._interval.unref();\n        }\n\n        this._debug('connect');\n\n        this.emit('connect');\n      });\n    };\n\n    findCandidatePair();\n  }\n\n  _onInterval() {\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n      return;\n    }\n\n    this._onChannelBufferedAmountLow();\n  }\n\n  _onSignalingStateChange() {\n    if (this.destroyed) return;\n\n    if (this._pc.signalingState === 'stable') {\n      this._isNegotiating = false; // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\n\n      this._debug('flushing sender queue', this._sendersAwaitingStable);\n\n      this._sendersAwaitingStable.forEach(sender => {\n        this._pc.removeTrack(sender);\n\n        this._queuedNegotiation = true;\n      });\n\n      this._sendersAwaitingStable = [];\n\n      if (this._queuedNegotiation) {\n        this._debug('flushing negotiation queue');\n\n        this._queuedNegotiation = false;\n\n        this._needsNegotiation(); // negotiate again\n\n      } else {\n        this._debug('negotiated');\n\n        this.emit('negotiated');\n      }\n    }\n\n    this._debug('signalingStateChange %s', this._pc.signalingState);\n\n    this.emit('signalingStateChange', this._pc.signalingState);\n  }\n\n  _onIceCandidate(event) {\n    if (this.destroyed) return;\n\n    if (event.candidate && this.trickle) {\n      this.emit('signal', {\n        type: 'candidate',\n        candidate: {\n          candidate: event.candidate.candidate,\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          sdpMid: event.candidate.sdpMid\n        }\n      });\n    } else if (!event.candidate && !this._iceComplete) {\n      this._iceComplete = true;\n      this.emit('_iceComplete');\n    } // as soon as we've received one valid candidate start timeout\n\n\n    if (event.candidate) {\n      this._startIceCompleteTimeout();\n    }\n  }\n\n  _onChannelMessage(event) {\n    if (this.destroyed) return;\n    let data = event.data;\n    if (data instanceof ArrayBuffer) data = Buffer.from(data);\n    this.push(data);\n  }\n\n  _onChannelBufferedAmountLow() {\n    if (this.destroyed || !this._cb) return;\n\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount);\n\n    const cb = this._cb;\n    this._cb = null;\n    cb(null);\n  }\n\n  _onChannelOpen() {\n    if (this._connected || this.destroyed) return;\n\n    this._debug('on channel open');\n\n    this._channelReady = true;\n\n    this._maybeReady();\n  }\n\n  _onChannelClose() {\n    if (this.destroyed) return;\n\n    this._debug('on channel close');\n\n    this.destroy();\n  }\n\n  _onTrack(event) {\n    if (this.destroyed) return;\n    event.streams.forEach(eventStream => {\n      this._debug('on track');\n\n      this.emit('track', event.track, eventStream);\n\n      this._remoteTracks.push({\n        track: event.track,\n        stream: eventStream\n      });\n\n      if (this._remoteStreams.some(remoteStream => {\n        return remoteStream.id === eventStream.id;\n      })) return; // Only fire one 'stream' event, even though there may be multiple tracks per stream\n\n      this._remoteStreams.push(eventStream);\n\n      queueMicrotask(() => {\n        this._debug('on stream');\n\n        this.emit('stream', eventStream); // ensure all tracks have been added\n      });\n    });\n  }\n\n  _debug() {\n    const args = [].slice.call(arguments);\n    args[0] = '[' + this._id + '] ' + args[0];\n    debug.apply(null, args);\n  }\n\n}\n\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC();\n/**\r\n * Expose peer and data channel config for overriding all Peer\r\n * instances. Otherwise, just set opts.config or opts.channelConfig\r\n * when constructing a Peer.\r\n */\n\nPeer.config = {\n  iceServers: [{\n    urls: ['stun:stun.l.google.com:19302', 'stun:global.stun.twilio.com:3478']\n  }],\n  sdpSemantics: 'unified-plan'\n};\nPeer.channelConfig = {};\nmodule.exports = Peer;","map":{"version":3,"sources":["C:/Users/HIRUNI/BACKEND/b/research-project-management-tool/frontend/node_modules/simple-peer/index.js"],"names":["debug","require","getBrowserRTC","randombytes","stream","queueMicrotask","errCode","Buffer","MAX_BUFFERED_AMOUNT","ICECOMPLETE_TIMEOUT","CHANNEL_CLOSING_TIMEOUT","filterTrickle","sdp","replace","warn","message","console","Peer","Duplex","constructor","opts","Object","assign","allowHalfOpen","_id","toString","slice","_debug","channelName","initiator","channelConfig","channelNegotiated","negotiated","config","offerOptions","answerOptions","sdpTransform","streams","trickle","undefined","allowHalfTrickle","iceCompleteTimeout","destroyed","destroying","_connected","remoteAddress","remoteFamily","remotePort","localAddress","localFamily","localPort","_wrtc","wrtc","window","Error","_pcReady","_channelReady","_iceComplete","_iceCompleteTimer","_channel","_pendingCandidates","_isNegotiating","_firstNegotiation","_batchedNegotiation","_queuedNegotiation","_sendersAwaitingStable","_senderMap","Map","_closingInterval","_remoteTracks","_remoteStreams","_chunk","_cb","_interval","_pc","RTCPeerConnection","err","destroy","_isReactNativeWebrtc","_peerConnectionId","oniceconnectionstatechange","_onIceStateChange","onicegatheringstatechange","onconnectionstatechange","_onConnectionStateChange","onsignalingstatechange","_onSignalingStateChange","onicecandidate","event","_onIceCandidate","peerIdentity","catch","_setupData","channel","createDataChannel","ondatachannel","forEach","addStream","ontrack","_onTrack","_needsNegotiation","_onFinishBound","_onFinish","once","bufferSize","bufferedAmount","connected","readyState","address","port","family","signal","data","JSON","parse","renegotiate","transceiverRequest","addTransceiver","kind","init","candidate","remoteDescription","type","_addIceCandidate","push","setRemoteDescription","RTCSessionDescription","then","_createAnswer","iceCandidateObj","RTCIceCandidate","addIceCandidate","endsWith","send","chunk","emit","getTracks","track","addTrack","submap","get","sender","set","removed","replaceTrack","oldTrack","newTrack","removeTrack","name","removeStream","negotiate","setTimeout","_createOffer","_destroy","cb","readable","writable","_readableState","ended","_writableState","finished","end","clearInterval","removeListener","close","onmessage","onopen","onclose","onerror","binaryType","bufferedAmountLowThreshold","label","_onChannelMessage","onbufferedamountlow","_onChannelBufferedAmountLow","_onChannelOpen","_onChannelClose","error","filename","lineno","colno","isClosing","setInterval","_read","_write","encoding","destroySoon","_startIceCompleteTimeout","createOffer","offer","sendOffer","localDescription","onSuccess","onError","setLocalDescription","_requestMissingTransceivers","getTransceivers","transceiver","mid","requested","createAnswer","answer","sendAnswer","connectionState","iceConnectionState","iceGatheringState","_maybeReady","getStats","flattenValues","report","prototype","call","values","value","length","res","reports","result","names","stat","id","timestamp","_connecting","findCandidatePair","items","remoteCandidates","localCandidates","candidatePairs","foundSelectedCandidatePair","item","setSelectedCandidatePair","selectedCandidatePair","local","localCandidateId","ip","Number","ipAddress","portNumber","googLocalAddress","split","includes","remote","remoteCandidateId","googRemoteAddress","selectedCandidatePairId","googActiveConnection","selected","keys","_onInterval","unref","signalingState","sdpMLineIndex","sdpMid","ArrayBuffer","from","eventStream","some","remoteStream","args","arguments","apply","WEBRTC_SUPPORT","iceServers","urls","sdpSemantics","module","exports"],"mappings":"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","sourcesContent":["/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\nconst debug = require('debug')('simple-peer')\r\nconst getBrowserRTC = require('get-browser-rtc')\r\nconst randombytes = require('randombytes')\r\nconst stream = require('readable-stream')\r\nconst queueMicrotask = require('queue-microtask') // TODO: remove when Node 10 is not supported\r\nconst errCode = require('err-code')\r\nconst { Buffer } = require('buffer')\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\nconst ICECOMPLETE_TIMEOUT = 5 * 1000\r\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\r\n\r\n// HACK: Filter trickle lines when trickle is disabled #354\r\nfunction filterTrickle (sdp) {\r\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\r\n}\r\n\r\nfunction warn (message) {\r\n  console.warn(message)\r\n}\r\n\r\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */\r\nclass Peer extends stream.Duplex {\r\n  constructor (opts) {\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this._id = randombytes(4).toString('hex').slice(0, 7)\r\n    this._debug('new peer %o', opts)\r\n\r\n    this.channelName = opts.initiator\r\n      ? opts.channelName || randombytes(20).toString('hex')\r\n      : null\r\n\r\n    this.initiator = opts.initiator || false\r\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\r\n    this.channelNegotiated = this.channelConfig.negotiated\r\n    this.config = Object.assign({}, Peer.config, opts.config)\r\n    this.offerOptions = opts.offerOptions || {}\r\n    this.answerOptions = opts.answerOptions || {}\r\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\r\n    this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old \"stream\" option\r\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\r\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\r\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\r\n\r\n    this.destroyed = false\r\n    this.destroying = false\r\n    this._connected = false\r\n\r\n    this.remoteAddress = undefined\r\n    this.remoteFamily = undefined\r\n    this.remotePort = undefined\r\n    this.localAddress = undefined\r\n    this.localFamily = undefined\r\n    this.localPort = undefined\r\n\r\n    this._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')\r\n      ? opts.wrtc\r\n      : getBrowserRTC()\r\n\r\n    if (!this._wrtc) {\r\n      if (typeof window === 'undefined') {\r\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')\r\n      } else {\r\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')\r\n      }\r\n    }\r\n\r\n    this._pcReady = false\r\n    this._channelReady = false\r\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\r\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\r\n    this._channel = null\r\n    this._pendingCandidates = []\r\n\r\n    this._isNegotiating = false // is this peer waiting for negotiation to complete?\r\n    this._firstNegotiation = true\r\n    this._batchedNegotiation = false // batch synchronous negotiations\r\n    this._queuedNegotiation = false // is there a queued negotiation request?\r\n    this._sendersAwaitingStable = []\r\n    this._senderMap = new Map()\r\n    this._closingInterval = null\r\n\r\n    this._remoteTracks = []\r\n    this._remoteStreams = []\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    try {\r\n      this._pc = new (this._wrtc.RTCPeerConnection)(this.config)\r\n    } catch (err) {\r\n      this.destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))\r\n      return\r\n    }\r\n\r\n    // We prefer feature detection whenever possible, but sometimes that's not\r\n    // possible for certain implementations.\r\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\r\n\r\n    this._pc.oniceconnectionstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onicegatheringstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onconnectionstatechange = () => {\r\n      this._onConnectionStateChange()\r\n    }\r\n    this._pc.onsignalingstatechange = () => {\r\n      this._onSignalingStateChange()\r\n    }\r\n    this._pc.onicecandidate = event => {\r\n      this._onIceCandidate(event)\r\n    }\r\n\r\n    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\r\n    if (typeof this._pc.peerIdentity === 'object') {\r\n      this._pc.peerIdentity.catch(err => {\r\n        this.destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))\r\n      })\r\n    }\r\n\r\n    // Other spec events, unused by this implementation:\r\n    // - onconnectionstatechange\r\n    // - onicecandidateerror\r\n    // - onfingerprintfailure\r\n    // - onnegotiationneeded\r\n\r\n    if (this.initiator || this.channelNegotiated) {\r\n      this._setupData({\r\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\r\n      })\r\n    } else {\r\n      this._pc.ondatachannel = event => {\r\n        this._setupData(event)\r\n      }\r\n    }\r\n\r\n    if (this.streams) {\r\n      this.streams.forEach(stream => {\r\n        this.addStream(stream)\r\n      })\r\n    }\r\n    this._pc.ontrack = event => {\r\n      this._onTrack(event)\r\n    }\r\n\r\n    this._debug('initial negotiation')\r\n    this._needsNegotiation()\r\n\r\n    this._onFinishBound = () => {\r\n      this._onFinish()\r\n    }\r\n    this.once('finish', this._onFinishBound)\r\n  }\r\n\r\n  get bufferSize () {\r\n    return (this._channel && this._channel.bufferedAmount) || 0\r\n  }\r\n\r\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n  get connected () {\r\n    return (this._connected && this._channel.readyState === 'open')\r\n  }\r\n\r\n  address () {\r\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\r\n  }\r\n\r\n  signal (data) {\r\n    if (this.destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')\r\n    if (typeof data === 'string') {\r\n      try {\r\n        data = JSON.parse(data)\r\n      } catch (err) {\r\n        data = {}\r\n      }\r\n    }\r\n    this._debug('signal()')\r\n\r\n    if (data.renegotiate && this.initiator) {\r\n      this._debug('got request to renegotiate')\r\n      this._needsNegotiation()\r\n    }\r\n    if (data.transceiverRequest && this.initiator) {\r\n      this._debug('got request for transceiver')\r\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\r\n    }\r\n    if (data.candidate) {\r\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\r\n        this._addIceCandidate(data.candidate)\r\n      } else {\r\n        this._pendingCandidates.push(data.candidate)\r\n      }\r\n    }\r\n    if (data.sdp) {\r\n      this._pc.setRemoteDescription(new (this._wrtc.RTCSessionDescription)(data))\r\n        .then(() => {\r\n          if (this.destroyed) return\r\n\r\n          this._pendingCandidates.forEach(candidate => {\r\n            this._addIceCandidate(candidate)\r\n          })\r\n          this._pendingCandidates = []\r\n\r\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\r\n        })\r\n        .catch(err => {\r\n          this.destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))\r\n        })\r\n    }\r\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\r\n      this.destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))\r\n    }\r\n  }\r\n\r\n  _addIceCandidate (candidate) {\r\n    const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate)\r\n    this._pc.addIceCandidate(iceCandidateObj)\r\n      .catch(err => {\r\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\r\n          warn('Ignoring unsupported ICE candidate.')\r\n        } else {\r\n          this.destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))\r\n        }\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the remote peer.\r\n   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk\r\n   */\r\n  send (chunk) {\r\n    if (this.destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._channel.send(chunk)\r\n  }\r\n\r\n  /**\r\n   * Add a Transceiver to the connection.\r\n   * @param {String} kind\r\n   * @param {Object} init\r\n   */\r\n  addTransceiver (kind, init) {\r\n    if (this.destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot addTransceiver after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._debug('addTransceiver()')\r\n\r\n    if (this.initiator) {\r\n      try {\r\n        this._pc.addTransceiver(kind, init)\r\n        this._needsNegotiation()\r\n      } catch (err) {\r\n        this.destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'))\r\n      }\r\n    } else {\r\n      this.emit('signal', { // request initiator to renegotiate\r\n        type: 'transceiverRequest',\r\n        transceiverRequest: { kind, init }\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a MediaStream to the connection.\r\n   * @param {MediaStream} stream\r\n   */\r\n  addStream (stream) {\r\n    if (this.destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot addStream after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._debug('addStream()')\r\n\r\n    stream.getTracks().forEach(track => {\r\n      this.addTrack(track, stream)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Add a MediaStreamTrack to the connection.\r\n   * @param {MediaStreamTrack} track\r\n   * @param {MediaStream} stream\r\n   */\r\n  addTrack (track, stream) {\r\n    if (this.destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot addTrack after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._debug('addTrack()')\r\n\r\n    const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender\r\n    let sender = submap.get(stream)\r\n    if (!sender) {\r\n      sender = this._pc.addTrack(track, stream)\r\n      submap.set(stream, sender)\r\n      this._senderMap.set(track, submap)\r\n      this._needsNegotiation()\r\n    } else if (sender.removed) {\r\n      throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED')\r\n    } else {\r\n      throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Replace a MediaStreamTrack by another in the connection.\r\n   * @param {MediaStreamTrack} oldTrack\r\n   * @param {MediaStreamTrack} newTrack\r\n   * @param {MediaStream} stream\r\n   */\r\n  replaceTrack (oldTrack, newTrack, stream) {\r\n    if (this.destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot replaceTrack after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._debug('replaceTrack()')\r\n\r\n    const submap = this._senderMap.get(oldTrack)\r\n    const sender = submap ? submap.get(stream) : null\r\n    if (!sender) {\r\n      throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED')\r\n    }\r\n    if (newTrack) this._senderMap.set(newTrack, submap)\r\n\r\n    if (sender.replaceTrack != null) {\r\n      sender.replaceTrack(newTrack)\r\n    } else {\r\n      this.destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a MediaStreamTrack from the connection.\r\n   * @param {MediaStreamTrack} track\r\n   * @param {MediaStream} stream\r\n   */\r\n  removeTrack (track, stream) {\r\n    if (this.destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot removeTrack after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._debug('removeSender()')\r\n\r\n    const submap = this._senderMap.get(track)\r\n    const sender = submap ? submap.get(stream) : null\r\n    if (!sender) {\r\n      throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED')\r\n    }\r\n    try {\r\n      sender.removed = true\r\n      this._pc.removeTrack(sender)\r\n    } catch (err) {\r\n      if (err.name === 'NS_ERROR_UNEXPECTED') {\r\n        this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\r\n      } else {\r\n        this.destroy(errCode(err, 'ERR_REMOVE_TRACK'))\r\n      }\r\n    }\r\n    this._needsNegotiation()\r\n  }\r\n\r\n  /**\r\n   * Remove a MediaStream from the connection.\r\n   * @param {MediaStream} stream\r\n   */\r\n  removeStream (stream) {\r\n    if (this.destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot removeStream after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._debug('removeSenders()')\r\n\r\n    stream.getTracks().forEach(track => {\r\n      this.removeTrack(track, stream)\r\n    })\r\n  }\r\n\r\n  _needsNegotiation () {\r\n    this._debug('_needsNegotiation')\r\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\r\n    this._batchedNegotiation = true\r\n    queueMicrotask(() => {\r\n      this._batchedNegotiation = false\r\n      if (this.initiator || !this._firstNegotiation) {\r\n        this._debug('starting batched negotiation')\r\n        this.negotiate()\r\n      } else {\r\n        this._debug('non-initiator initial negotiation request discarded')\r\n      }\r\n      this._firstNegotiation = false\r\n    })\r\n  }\r\n\r\n  negotiate () {\r\n    if (this.destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')\r\n\r\n    if (this.initiator) {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('start negotiation')\r\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\r\n          this._createOffer()\r\n        }, 0)\r\n      }\r\n    } else {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('requesting negotiation from initiator')\r\n        this.emit('signal', { // request initiator to renegotiate\r\n          type: 'renegotiate',\r\n          renegotiate: true\r\n        })\r\n      }\r\n    }\r\n    this._isNegotiating = true\r\n  }\r\n\r\n  // TODO: Delete this method once readable-stream is updated to contain a default\r\n  // implementation of destroy() that automatically calls _destroy()\r\n  // See: https://github.com/nodejs/readable-stream/issues/283\r\n  destroy (err) {\r\n    this._destroy(err, () => {})\r\n  }\r\n\r\n  _destroy (err, cb) {\r\n    if (this.destroyed || this.destroying) return\r\n    this.destroying = true\r\n\r\n    this._debug('destroying (error: %s)', err && (err.message || err))\r\n\r\n    queueMicrotask(() => { // allow events concurrent with the call to _destroy() to fire (see #692)\r\n      this.destroyed = true\r\n      this.destroying = false\r\n\r\n      this._debug('destroy (error: %s)', err && (err.message || err))\r\n\r\n      this.readable = this.writable = false\r\n\r\n      if (!this._readableState.ended) this.push(null)\r\n      if (!this._writableState.finished) this.end()\r\n\r\n      this._connected = false\r\n      this._pcReady = false\r\n      this._channelReady = false\r\n      this._remoteTracks = null\r\n      this._remoteStreams = null\r\n      this._senderMap = null\r\n\r\n      clearInterval(this._closingInterval)\r\n      this._closingInterval = null\r\n\r\n      clearInterval(this._interval)\r\n      this._interval = null\r\n      this._chunk = null\r\n      this._cb = null\r\n\r\n      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\r\n      this._onFinishBound = null\r\n\r\n      if (this._channel) {\r\n        try {\r\n          this._channel.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._channel.onmessage = null\r\n        this._channel.onopen = null\r\n        this._channel.onclose = null\r\n        this._channel.onerror = null\r\n      }\r\n      if (this._pc) {\r\n        try {\r\n          this._pc.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._pc.oniceconnectionstatechange = null\r\n        this._pc.onicegatheringstatechange = null\r\n        this._pc.onsignalingstatechange = null\r\n        this._pc.onicecandidate = null\r\n        this._pc.ontrack = null\r\n        this._pc.ondatachannel = null\r\n      }\r\n      this._pc = null\r\n      this._channel = null\r\n\r\n      if (err) this.emit('error', err)\r\n      this.emit('close')\r\n      cb()\r\n    })\r\n  }\r\n\r\n  _setupData (event) {\r\n    if (!event.channel) {\r\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\r\n      // which is invalid behavior. Handle it gracefully.\r\n      // See: https://github.com/feross/simple-peer/issues/163\r\n      return this.destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    this._channel = event.channel\r\n    this._channel.binaryType = 'arraybuffer'\r\n\r\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\r\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\r\n    }\r\n\r\n    this.channelName = this._channel.label\r\n\r\n    this._channel.onmessage = event => {\r\n      this._onChannelMessage(event)\r\n    }\r\n    this._channel.onbufferedamountlow = () => {\r\n      this._onChannelBufferedAmountLow()\r\n    }\r\n    this._channel.onopen = () => {\r\n      this._onChannelOpen()\r\n    }\r\n    this._channel.onclose = () => {\r\n      this._onChannelClose()\r\n    }\r\n    this._channel.onerror = event => {\r\n      const err = event.error instanceof Error\r\n        ? event.error\r\n        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)\r\n      this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\r\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n    let isClosing = false\r\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\r\n      if (this._channel && this._channel.readyState === 'closing') {\r\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\r\n        isClosing = true\r\n      } else {\r\n        isClosing = false\r\n      }\r\n    }, CHANNEL_CLOSING_TIMEOUT)\r\n  }\r\n\r\n  _read () {}\r\n\r\n  _write (chunk, encoding, cb) {\r\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))\r\n\r\n    if (this._connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n      }\r\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _onFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.destroy(), 1000)\r\n    }\r\n\r\n    if (this._connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _startIceCompleteTimeout () {\r\n    if (this.destroyed) return\r\n    if (this._iceCompleteTimer) return\r\n    this._debug('started iceComplete timeout')\r\n    this._iceCompleteTimer = setTimeout(() => {\r\n      if (!this._iceComplete) {\r\n        this._iceComplete = true\r\n        this._debug('iceComplete timeout completed')\r\n        this.emit('iceTimeout')\r\n        this.emit('_iceComplete')\r\n      }\r\n    }, this.iceCompleteTimeout)\r\n  }\r\n\r\n  _createOffer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createOffer(this.offerOptions)\r\n      .then(offer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\r\n        offer.sdp = this.sdpTransform(offer.sdp)\r\n\r\n        const sendOffer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || offer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          this._debug('createOffer success')\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendOffer()\r\n          else this.once('_iceComplete', sendOffer) // wait for candidates\r\n        }\r\n\r\n        const onError = err => {\r\n          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(offer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.destroy(errCode(err, 'ERR_CREATE_OFFER'))\r\n      })\r\n  }\r\n\r\n  _requestMissingTransceivers () {\r\n    if (this._pc.getTransceivers) {\r\n      this._pc.getTransceivers().forEach(transceiver => {\r\n        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\r\n          transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid\r\n          this.addTransceiver(transceiver.sender.track.kind)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  _createAnswer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createAnswer(this.answerOptions)\r\n      .then(answer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\r\n        answer.sdp = this.sdpTransform(answer.sdp)\r\n\r\n        const sendAnswer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || answer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n          if (!this.initiator) this._requestMissingTransceivers()\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendAnswer()\r\n          else this.once('_iceComplete', sendAnswer)\r\n        }\r\n\r\n        const onError = err => {\r\n          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(answer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.destroy(errCode(err, 'ERR_CREATE_ANSWER'))\r\n      })\r\n  }\r\n\r\n  _onConnectionStateChange () {\r\n    if (this.destroyed) return\r\n    if (this._pc.connectionState === 'failed') {\r\n      this.destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))\r\n    }\r\n  }\r\n\r\n  _onIceStateChange () {\r\n    if (this.destroyed) return\r\n    const iceConnectionState = this._pc.iceConnectionState\r\n    const iceGatheringState = this._pc.iceGatheringState\r\n\r\n    this._debug(\r\n      'iceStateChange (connection: %s) (gathering: %s)',\r\n      iceConnectionState,\r\n      iceGatheringState\r\n    )\r\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\r\n\r\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\r\n      this._pcReady = true\r\n      this._maybeReady()\r\n    }\r\n    if (iceConnectionState === 'failed') {\r\n      this.destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))\r\n    }\r\n    if (iceConnectionState === 'closed') {\r\n      this.destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))\r\n    }\r\n  }\r\n\r\n  getStats (cb) {\r\n    // statreports can come with a value array instead of properties\r\n    const flattenValues = report => {\r\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\r\n        report.values.forEach(value => {\r\n          Object.assign(report, value)\r\n        })\r\n      }\r\n      return report\r\n    }\r\n\r\n    // Promise-based getStats() (standard)\r\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\r\n      this._pc.getStats()\r\n        .then(res => {\r\n          const reports = []\r\n          res.forEach(report => {\r\n            reports.push(flattenValues(report))\r\n          })\r\n          cb(null, reports)\r\n        }, err => cb(err))\r\n\r\n    // Single-parameter callback-based getStats() (non-standard)\r\n    } else if (this._pc.getStats.length > 0) {\r\n      this._pc.getStats(res => {\r\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\r\n        if (this.destroyed) return\r\n\r\n        const reports = []\r\n        res.result().forEach(result => {\r\n          const report = {}\r\n          result.names().forEach(name => {\r\n            report[name] = result.stat(name)\r\n          })\r\n          report.id = result.id\r\n          report.type = result.type\r\n          report.timestamp = result.timestamp\r\n          reports.push(flattenValues(report))\r\n        })\r\n        cb(null, reports)\r\n      }, err => cb(err))\r\n\r\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\r\n    // getStats() they implement.\r\n    } else {\r\n      cb(null, [])\r\n    }\r\n  }\r\n\r\n  _maybeReady () {\r\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\r\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\r\n\r\n    this._connecting = true\r\n\r\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\r\n    const findCandidatePair = () => {\r\n      if (this.destroyed) return\r\n\r\n      this.getStats((err, items) => {\r\n        if (this.destroyed) return\r\n\r\n        // Treat getStats error as non-fatal. It's not essential.\r\n        if (err) items = []\r\n\r\n        const remoteCandidates = {}\r\n        const localCandidates = {}\r\n        const candidatePairs = {}\r\n        let foundSelectedCandidatePair = false\r\n\r\n        items.forEach(item => {\r\n          // TODO: Once all browsers support the hyphenated stats report types, remove\r\n          // the non-hypenated ones\r\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\r\n            remoteCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\r\n            localCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\r\n            candidatePairs[item.id] = item\r\n          }\r\n        })\r\n\r\n        const setSelectedCandidatePair = selectedCandidatePair => {\r\n          foundSelectedCandidatePair = true\r\n\r\n          let local = localCandidates[selectedCandidatePair.localCandidateId]\r\n\r\n          if (local && (local.ip || local.address)) {\r\n            // Spec\r\n            this.localAddress = local.ip || local.address\r\n            this.localPort = Number(local.port)\r\n          } else if (local && local.ipAddress) {\r\n            // Firefox\r\n            this.localAddress = local.ipAddress\r\n            this.localPort = Number(local.portNumber)\r\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            local = selectedCandidatePair.googLocalAddress.split(':')\r\n            this.localAddress = local[0]\r\n            this.localPort = Number(local[1])\r\n          }\r\n          if (this.localAddress) {\r\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\r\n\r\n          if (remote && (remote.ip || remote.address)) {\r\n            // Spec\r\n            this.remoteAddress = remote.ip || remote.address\r\n            this.remotePort = Number(remote.port)\r\n          } else if (remote && remote.ipAddress) {\r\n            // Firefox\r\n            this.remoteAddress = remote.ipAddress\r\n            this.remotePort = Number(remote.portNumber)\r\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\r\n            this.remoteAddress = remote[0]\r\n            this.remotePort = Number(remote[1])\r\n          }\r\n          if (this.remoteAddress) {\r\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          this._debug(\r\n            'connect local: %s:%s remote: %s:%s',\r\n            this.localAddress,\r\n            this.localPort,\r\n            this.remoteAddress,\r\n            this.remotePort\r\n          )\r\n        }\r\n\r\n        items.forEach(item => {\r\n          // Spec-compliant\r\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\r\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\r\n          }\r\n\r\n          // Old implementations\r\n          if (\r\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\r\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\r\n          ) {\r\n            setSelectedCandidatePair(item)\r\n          }\r\n        })\r\n\r\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\r\n        // But wait until at least 1 candidate pair is available\r\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\r\n          setTimeout(findCandidatePair, 100)\r\n          return\r\n        } else {\r\n          this._connecting = false\r\n          this._connected = true\r\n        }\r\n\r\n        if (this._chunk) {\r\n          try {\r\n            this.send(this._chunk)\r\n          } catch (err) {\r\n            return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n          }\r\n          this._chunk = null\r\n          this._debug('sent chunk from \"write before connect\"')\r\n\r\n          const cb = this._cb\r\n          this._cb = null\r\n          cb(null)\r\n        }\r\n\r\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\r\n        // fallback to using setInterval to implement backpressure.\r\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\r\n          this._interval = setInterval(() => this._onInterval(), 150)\r\n          if (this._interval.unref) this._interval.unref()\r\n        }\r\n\r\n        this._debug('connect')\r\n        this.emit('connect')\r\n      })\r\n    }\r\n    findCandidatePair()\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._onChannelBufferedAmountLow()\r\n  }\r\n\r\n  _onSignalingStateChange () {\r\n    if (this.destroyed) return\r\n\r\n    if (this._pc.signalingState === 'stable') {\r\n      this._isNegotiating = false\r\n\r\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\r\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\r\n      this._sendersAwaitingStable.forEach(sender => {\r\n        this._pc.removeTrack(sender)\r\n        this._queuedNegotiation = true\r\n      })\r\n      this._sendersAwaitingStable = []\r\n\r\n      if (this._queuedNegotiation) {\r\n        this._debug('flushing negotiation queue')\r\n        this._queuedNegotiation = false\r\n        this._needsNegotiation() // negotiate again\r\n      } else {\r\n        this._debug('negotiated')\r\n        this.emit('negotiated')\r\n      }\r\n    }\r\n\r\n    this._debug('signalingStateChange %s', this._pc.signalingState)\r\n    this.emit('signalingStateChange', this._pc.signalingState)\r\n  }\r\n\r\n  _onIceCandidate (event) {\r\n    if (this.destroyed) return\r\n    if (event.candidate && this.trickle) {\r\n      this.emit('signal', {\r\n        type: 'candidate',\r\n        candidate: {\r\n          candidate: event.candidate.candidate,\r\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\r\n          sdpMid: event.candidate.sdpMid\r\n        }\r\n      })\r\n    } else if (!event.candidate && !this._iceComplete) {\r\n      this._iceComplete = true\r\n      this.emit('_iceComplete')\r\n    }\r\n    // as soon as we've received one valid candidate start timeout\r\n    if (event.candidate) {\r\n      this._startIceCompleteTimeout()\r\n    }\r\n  }\r\n\r\n  _onChannelMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) data = Buffer.from(data)\r\n    this.push(data)\r\n  }\r\n\r\n  _onChannelBufferedAmountLow () {\r\n    if (this.destroyed || !this._cb) return\r\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _onChannelOpen () {\r\n    if (this._connected || this.destroyed) return\r\n    this._debug('on channel open')\r\n    this._channelReady = true\r\n    this._maybeReady()\r\n  }\r\n\r\n  _onChannelClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on channel close')\r\n    this.destroy()\r\n  }\r\n\r\n  _onTrack (event) {\r\n    if (this.destroyed) return\r\n\r\n    event.streams.forEach(eventStream => {\r\n      this._debug('on track')\r\n      this.emit('track', event.track, eventStream)\r\n\r\n      this._remoteTracks.push({\r\n        track: event.track,\r\n        stream: eventStream\r\n      })\r\n\r\n      if (this._remoteStreams.some(remoteStream => {\r\n        return remoteStream.id === eventStream.id\r\n      })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream\r\n\r\n      this._remoteStreams.push(eventStream)\r\n      queueMicrotask(() => {\r\n        this._debug('on stream')\r\n        this.emit('stream', eventStream) // ensure all tracks have been added\r\n      })\r\n    })\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    debug.apply(null, args)\r\n  }\r\n}\r\n\r\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC()\r\n\r\n/**\r\n * Expose peer and data channel config for overriding all Peer\r\n * instances. Otherwise, just set opts.config or opts.channelConfig\r\n * when constructing a Peer.\r\n */\r\nPeer.config = {\r\n  iceServers: [\r\n    {\r\n      urls: [\r\n        'stun:stun.l.google.com:19302',\r\n        'stun:global.stun.twilio.com:3478'\r\n      ]\r\n    }\r\n  ],\r\n  sdpSemantics: 'unified-plan'\r\n}\r\n\r\nPeer.channelConfig = {}\r\n\r\nmodule.exports = Peer\r\n"]},"metadata":{},"sourceType":"script"}