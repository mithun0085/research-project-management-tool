{"ast":null,"code":"import { NEW_FOCUS, newFocus } from './solver';\nimport { filterAutoFocusable, getAllTabbableNodes, getTabbableNodes } from './utils/DOMutils';\nimport { getAllAffectedNodes } from './utils/all-affected';\nimport { pickFirstFocus } from './utils/firstFocus';\nimport { getActiveElement } from './utils/getActiveElement';\nimport { getDataset, isDefined, isNotAGuard } from './utils/is';\nimport { allParentAutofocusables, getTopCommonParent } from './utils/parenting';\n\nvar findAutoFocused = function (autoFocusables) {\n  return function (node) {\n    var _a; // @ts-expect-error\n\n\n    return node.autofocus || !!((_a = getDataset(node)) === null || _a === void 0 ? void 0 : _a.autofocus) || autoFocusables.indexOf(node) >= 0;\n  };\n};\n\nvar reorderNodes = function (srcNodes, dstNodes) {\n  var remap = new Map(); // no Set(dstNodes) for IE11 :(\n\n  dstNodes.forEach(function (entity) {\n    return remap.set(entity.node, entity);\n  }); // remap to dstNodes\n\n  return srcNodes.map(function (node) {\n    return remap.get(node);\n  }).filter(isDefined);\n};\n/**\n * given top node(s) and the last active element return the element to be focused next\n * @param topNode\n * @param lastNode\n */\n\n\nexport var getFocusMerge = function (topNode, lastNode) {\n  var activeElement = document && getActiveElement();\n  var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);\n  var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);\n  var visibilityCache = new Map();\n  var anyFocusable = getAllTabbableNodes(entries, visibilityCache);\n  var innerElements = getTabbableNodes(entries, visibilityCache).filter(function (_a) {\n    var node = _a.node;\n    return isNotAGuard(node);\n  });\n\n  if (!innerElements[0]) {\n    innerElements = anyFocusable;\n\n    if (!innerElements[0]) {\n      return undefined;\n    }\n  }\n\n  var outerNodes = getAllTabbableNodes([commonParent], visibilityCache).map(function (_a) {\n    var node = _a.node;\n    return node;\n  });\n  var orderedInnerElements = reorderNodes(outerNodes, innerElements);\n  var innerNodes = orderedInnerElements.map(function (_a) {\n    var node = _a.node;\n    return node;\n  });\n  var newId = newFocus(innerNodes, outerNodes, activeElement, lastNode);\n\n  if (newId === NEW_FOCUS) {\n    var autoFocusable = filterAutoFocusable(anyFocusable.map(function (_a) {\n      var node = _a.node;\n      return node;\n    })).filter(findAutoFocused(allParentAutofocusables(entries, visibilityCache)));\n    return {\n      node: autoFocusable && autoFocusable.length ? pickFirstFocus(autoFocusable) : pickFirstFocus(filterAutoFocusable(innerNodes))\n    };\n  }\n\n  if (newId === undefined) {\n    return newId;\n  }\n\n  return orderedInnerElements[newId];\n};","map":{"version":3,"sources":["E:/Group Projects/AF Project/research-project-management-tool/frontend/node_modules/focus-lock/dist/es2015/focusMerge.js"],"names":["NEW_FOCUS","newFocus","filterAutoFocusable","getAllTabbableNodes","getTabbableNodes","getAllAffectedNodes","pickFirstFocus","getActiveElement","getDataset","isDefined","isNotAGuard","allParentAutofocusables","getTopCommonParent","findAutoFocused","autoFocusables","node","_a","autofocus","indexOf","reorderNodes","srcNodes","dstNodes","remap","Map","forEach","entity","set","map","get","filter","getFocusMerge","topNode","lastNode","activeElement","document","entries","commonParent","visibilityCache","anyFocusable","innerElements","undefined","outerNodes","orderedInnerElements","innerNodes","newId","autoFocusable","length"],"mappings":"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","sourcesContent":["import { NEW_FOCUS, newFocus } from './solver';\nimport { filterAutoFocusable, getAllTabbableNodes, getTabbableNodes } from './utils/DOMutils';\nimport { getAllAffectedNodes } from './utils/all-affected';\nimport { pickFirstFocus } from './utils/firstFocus';\nimport { getActiveElement } from './utils/getActiveElement';\nimport { getDataset, isDefined, isNotAGuard } from './utils/is';\nimport { allParentAutofocusables, getTopCommonParent } from './utils/parenting';\nvar findAutoFocused = function (autoFocusables) {\n    return function (node) { var _a; \n    // @ts-expect-error\n    return node.autofocus || !!((_a = getDataset(node)) === null || _a === void 0 ? void 0 : _a.autofocus) || autoFocusables.indexOf(node) >= 0; };\n};\nvar reorderNodes = function (srcNodes, dstNodes) {\n    var remap = new Map();\n    // no Set(dstNodes) for IE11 :(\n    dstNodes.forEach(function (entity) { return remap.set(entity.node, entity); });\n    // remap to dstNodes\n    return srcNodes.map(function (node) { return remap.get(node); }).filter(isDefined);\n};\n/**\n * given top node(s) and the last active element return the element to be focused next\n * @param topNode\n * @param lastNode\n */\nexport var getFocusMerge = function (topNode, lastNode) {\n    var activeElement = document && getActiveElement();\n    var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);\n    var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);\n    var visibilityCache = new Map();\n    var anyFocusable = getAllTabbableNodes(entries, visibilityCache);\n    var innerElements = getTabbableNodes(entries, visibilityCache).filter(function (_a) {\n        var node = _a.node;\n        return isNotAGuard(node);\n    });\n    if (!innerElements[0]) {\n        innerElements = anyFocusable;\n        if (!innerElements[0]) {\n            return undefined;\n        }\n    }\n    var outerNodes = getAllTabbableNodes([commonParent], visibilityCache).map(function (_a) {\n        var node = _a.node;\n        return node;\n    });\n    var orderedInnerElements = reorderNodes(outerNodes, innerElements);\n    var innerNodes = orderedInnerElements.map(function (_a) {\n        var node = _a.node;\n        return node;\n    });\n    var newId = newFocus(innerNodes, outerNodes, activeElement, lastNode);\n    if (newId === NEW_FOCUS) {\n        var autoFocusable = filterAutoFocusable(anyFocusable.map(function (_a) {\n            var node = _a.node;\n            return node;\n        })).filter(findAutoFocused(allParentAutofocusables(entries, visibilityCache)));\n        return {\n            node: autoFocusable && autoFocusable.length\n                ? pickFirstFocus(autoFocusable)\n                : pickFirstFocus(filterAutoFocusable(innerNodes)),\n        };\n    }\n    if (newId === undefined) {\n        return newId;\n    }\n    return orderedInnerElements[newId];\n};\n"]},"metadata":{},"sourceType":"module"}